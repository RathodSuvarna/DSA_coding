System Design & Architecture

1. Explain SOLID principles with examples.
Answer:
SOLID is a set of five principles for designing maintainable and scalable software:

S: Single Responsibility Principle
    Every class should have only one responsibility.
    Class should have only one reason to change
    Example: In a payment module, I separated payment processing logic into a PaymentProcessor class and transaction
    logging into a TransactionLogger class.

O: Open-Closed Principle
    Code should be open for extension but closed for modification.
    Example: I used interfaces for payment methods, so adding new methods (like UPI or wallet) required creating a
    new implementation, not modifying existing classes.

L: Liskov Substitution Principle
    Subtypes should be substitutable for their base types.
    if we have piece of code work with parent class it should work with any sub class of that parent class without
    requiring changes or unexpected behavior .
    Example: I ensured CreditCardPayment and DebitCardPayment both adhered to a Payment interface without breaking
    functionality.

I: Interface Segregation Principle
    Clients should not be forced to implement interfaces they don‚Äôt use.
    Example: I split a large OrderService interface into smaller ones like OrderPlacementService
    and OrderTrackingService.

D: Dependency Inversion Principle
    High-level modules should depend on abstractions, not concrete implementations.
    High level modules should not depend on low leve modules. both should depend on Abstraction.
    Example: I used Spring Boot‚Äôs dependency injection to inject a NotificationService rather than instantiating it directly.

2. What is a Singleton Pattern?
Ans: 	The Singleton Pattern ensures that a class has only one instance and provides a global point of access to it.
	It is often used for logging, database connections, or configuration classes.

	Implementation:=
	public class Singleton {
	    private static Singleton instance;
	    private Singleton() {}
	    public static synchronized Singleton getInstance() {
	    if (instance == null) {
	    instance = new Singleton();
	    }
	  return instance;
	  }
	}
--------------------------------------------------------------------------------------------------------------------------------------------------

3. What is a Factory Pattern?
   Answer: The Factory Pattern provides an interface for creating objects but allows subclasses to alter the type of
   objects that will be created. It helps promote loose coupling.

   Implementation:
   public interface Shape {
       void draw();
   }

   public class Circle implements Shape {
       public void draw() { System.out.println("Drawing Circle"); }
   }
   public class ShapeFactory {
       public static Shape getShape(String type) {
           if (type.equalsIgnoreCase("CIRCLE")) {
               return new Circle();
           }
           return null;
       }
   }
--------------------------------------------------------------------------------------------------------------------------------------------------
4. What is the Builder Pattern?
Answer: The Builder Pattern constructs complex objects step by step, allowing more control over the object creation process.
It is often used for creating immutable object

public class User {
    private String name;
    private int age;

    private User(UserBuilder builder) {
        this.name = builder.name;
        this.age = builder.age;
    }

    public static class UserBuilder {
        private String name;
        private int age;

        public UserBuilder setName(String name) {
            this.name = name;
            return this;
        }

        public UserBuilder setAge(int age) {
            this.age = age;
            return this;
        }

        public User build() {
            return new User(this);
        }
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------
5. How would you design a scalable REST API?
Answer:
To design a scalable REST API, we can make it stateless, horizontally scalable, and fault-tolerant.
we use an API Gateway for routing, authentication, and rate limiting, and deploy multiple stateless instances of the
service behind a load balancer.

For performance, I‚Äôd use caching (Redis), pagination, and asynchronous processing (Kafka or RabbitMQ) for heavy tasks.
Data would be stored in a scalable database (like RDS or DynamoDB), with read replicas for high read loads.
Security would be handled using JWT/OAuth2 authentication and HTTPS.

For resilience and monitoring, I‚Äôd add circuit breakers (Resilience4j), logging (ELK), metrics (Prometheus/Grafana),
and distributed tracing (Jaeger).
Finally, I‚Äôd ensure CI/CD pipelines (Jenkins/GitHub Actions) for automated deployment and scaling using Docker and Kubernetes.

‚úÖ In short (key points):
Stateless services ‚Üí easy horizontal scaling
Load balancer + API Gateway ‚Üí routing, rate limiting, auth
Caching ‚Üí Redis, CDN for performance
Database scaling ‚Üí read replicas, partitioning
Async processing ‚Üí Kafka/RabbitMQ
Security ‚Üí JWT, HTTPS, role-based access
Monitoring & CI/CD ‚Üí Prometheus, Jenkins, K8s for auto-scaling
========================================================================================================================
6. What is CQRS and where would you use it?
Answer:
CQRS (Command Query Responsibility Segregation) is a design pattern that separates read and write operations in
an application.

In simple terms ‚Äî
Commands are used to modify data (Create, Update, Delete).
Queries are used to read or fetch data.
Instead of using the same model for both, CQRS uses different models:
A write model that handles commands and updates the database.
A read model that handles queries and is optimized for fast reads.

üìç Where to use CQRS:
You‚Äôd use CQRS in complex, high-scale systems where:
Read and write operations have different performance requirements.
were we need event-driven architecture (often used with Event Sourcing).
There are frequent reads but fewer writes, like in reporting or analytics systems.
if we want to maintain data consistency and scalability independently for reads and writes.

üß† Example:
In an e-commerce system,
The order placement (write) logic updates inventory and user balance.
The order tracking (read) logic just fetches data to display order status.
Using CQRS lets you scale reads separately from writes, improving performance.
========================================================================================================================
7. Explain Event-driven architecture and Kafka‚Äôs role in it.
Event-Driven Architecture (EDA):
Event-Driven Architecture is a design pattern where components communicate through events instead of direct calls.
An event represents a change in the system ‚Äî e.g., ‚ÄúOrder Placed‚Äù, ‚ÄúPayment Completed‚Äù, or ‚ÄúUser Registered‚Äù.
In EDA, services are loosely coupled:
A producer publishes events when something happens.
One or more consumers listen for those events and react to them.
This makes the system asynchronous, scalable, and fault-tolerant ‚Äî perfect for microservices.

‚öôÔ∏è Kafka‚Äôs Role:
Apache Kafka acts as the central event broker or message bus in an event-driven system.
Producers publish events to Kafka topics.
Consumers subscribe to those topics and process the events.
Kafka ensures durability, scalability, and fault tolerance.
It decouples services ‚Äî meaning producers and consumers don‚Äôt need to know about each other.

üß† Example:
In an e-commerce app:
When a user places an order, the Order Service publishes an OrderPlaced event to Kafka.
The Inventory Service consumes it and updates stock.
The Notification Service consumes it and sends an email.
All these happen asynchronously without blocking the main order flow.

‚úÖ Key Benefits:
Loose coupling between services
Asynchronous communication
Better scalability and fault tolerance
Real-time data streaming
========================================================================================================================
8. What is load balancing, and how does it improve scalability?
Load balancing is the process of distributing incoming network traffic evenly across multiple servers or instances
to ensure no single server is overwhelmed.

‚öôÔ∏è How It Improves Scalability:
Improves performance: Requests are spread across multiple servers, so each one handles less load.
Increases scalability: You can easily add or remove servers behind the load balancer as traffic changes.
Enhances availability: If one server fails, the load balancer automatically routes traffic to healthy ones
(high availability).
Optimizes resource usage: Ensures all servers are utilized efficiently instead of some being idle while others
are overloaded.

üß† Example:
In an e-commerce application, an AWS Elastic Load Balancer (ELB) can route incoming user requests across multiple
EC2 instances running the same backend service ‚Äî keeping the app responsive even during peak traffic.

In short:
Load balancing distributes traffic across multiple servers to improve performance, scalability, and reliability.
========================================================================================================================
9. How does caching (Redis, Ehcache) improve performance?
Caching (using tools like Redis or Ehcache) improves performance by storing frequently accessed data in memory
so that future requests can be served faster without hitting the database every time.

‚öôÔ∏è How it helps:
Reduces database load: Frequently accessed queries (like user sessions, product lists) are fetched from
cache instead of DB.
Improves response time: In-memory data retrieval is much faster than querying a database.
Enhances scalability: Applications can handle more users without increasing database traffic.
Improves fault tolerance: Redis can persist cache and support replication for high availability.

üß† Example:
When a user fetches product details, the first request hits the database and stores the result in Redis.
Next time, the same data is returned directly from Redis ‚Äî reducing latency and improving performance.

In short:
Caching improves performance by serving frequently used data from fast in-memory stores like Redis or Ehcache,
 reducing database calls and response times.
========================================================================================================================
10. Explain Circuit Breaker pattern in microservices.
Circuit Breaker Pattern (in Microservices)
The Circuit Breaker pattern is used to prevent cascading failures in microservices when one service repeatedly c
alls another that is slow or unavailable.
It ‚Äúbreaks‚Äù the connection temporarily after a certain number of failures ‚Äî just like an electrical circuit breaker.

‚öôÔ∏è How It Works:
Closed State:
Requests flow normally to the dependent service. If failures exceed a threshold (e.g., 5 consecutive failures),
the breaker ‚Äúopens.‚Äù

Open State:
Calls are immediately blocked (fail fast) instead of waiting for timeouts.This prevents resource exhaustion and
reduces system load.

Half-Open State:
After a cooldown period, a few test requests are allowed through.If they succeed, the breaker closes again; if not,
it stays open.

üß† Example:
If Service A calls Service B (which is down), the circuit breaker (e.g., Resilience4j or Hystrix) stops Service A
from continuously retrying. This ensures Service A remains stable and responsive.

‚úÖ In short:
The Circuit Breaker pattern improves resilience in microservices by stopping repeated calls to a failing service and
allowing recovery once it becomes healthy again.
========================================================================================================================
11. How would you design a notification service or payment system?
1Ô∏è‚É£ Designing a Notification Service
Goal: Send notifications (Email, SMS, Push) reliably and asynchronously.
Architecture Overview:
Clients / Services: (e.g., Order Service, User Service) send notification requests.
Notification API: Receives requests (e.g., /sendNotification).
Message Queue: (Kafka / RabbitMQ / SQS) stores requests asynchronously.
Notification Processor: Listens to the queue, processes messages, and sends notifications via specific
channels (Email/SMS/Push).
Channel Providers: External APIs like Twilio (SMS), AWS SES (Email), Firebase (Push).
Database (optional): Stores delivery status and retries.

Tech Stack Example:
Spring Boot (REST API + Kafka consumer)
Kafka (for async communication)
Redis (for rate limiting / caching)
AWS SES / Twilio / Firebase (for sending notifications)

Key Considerations:
Asynchronous processing: Avoid blocking client requests.
Retry mechanism: Retry failed messages with exponential backoff.
Idempotency: Ensure the same message isn‚Äôt sent twice.
Monitoring: Track delivery and failure rates.

‚úÖ In short:
A notification service uses event-driven architecture (e.g., Kafka) to send notifications asynchronously through
 different channels, ensuring reliability, scalability, and fault tolerance.

üí∞ 2Ô∏è‚É£ Designing a Payment System
Goal: Process payments safely, reliably, and idempotency.
Architecture Overview:
Client / Checkout Service: Initiates payment (order info, amount, user).
Payment Gateway API: Handles requests and integrates with external providers (Razorpay, Stripe, PayPal).
Payment Processor Service:
Validates requests
Interacts with gateway
Updates payment status (PENDING ‚Üí SUCCESS/FAILURE)
Database: Stores transaction details.
Event Bus: Publishes payment success/failure events to Order/Notification services.
Security: Uses encryption, HTTPS, JWT, and secure tokens.

Key Considerations:
Idempotency: Same payment should not be processed twice.
Consistency: Use distributed transactions or Saga Pattern to maintain order-payment consistency.
Retry logic: Handle network failures safely.
Security: Mask card details, use PCI DSS-compliant gateways.

‚úÖ In short:
A payment system is designed with secure, idempotent, event-driven architecture, integrating with payment gateways and
ensuring reliable updates using patterns like Saga and event-based communication.

