1. What is the Saga Pattern?
Definition:
The Saga Pattern is a design pattern for managing distributed transactions in microservices. Instead of using a single
global transaction, it breaks a transaction into a series of smaller steps, where each step is a local transaction in a service.
If one step fails, a compensating action is triggered to rollback changes made by the previous steps.

Use Case in Payment Systems:
A payment processing workflow that involves multiple services like Order Service, Payment Service, and Inventory Service.
If payment fails, the order and inventory changes should be rolled back.

Example:
    // Step 1: Place Order
    class PlaceOrderService {
        public void placeOrder(String orderId) {
            System.out.println("Order placed: " + orderId);
        }

        public void rollbackOrder(String orderId) {
            System.out.println("Order rolled back: " + orderId);
        }
    }

    // Step 2: Deduct Payment
    class PaymentService {
        public void processPayment(String orderId, double amount) {
            if (amount > 1000) {
                throw new RuntimeException("Payment failed for order: " + orderId);
            }
            System.out.println("Payment processed for order: " + orderId);
        }

        public void refundPayment(String orderId) {
            System.out.println("Payment refunded for order: " + orderId);
        }
    }

    // Step 3: Update Inventory
    class InventoryService {
        public void updateInventory(String orderId) {
            System.out.println("Inventory updated for order: " + orderId);
        }

        public void rollbackInventory(String orderId) {
            System.out.println("Inventory rollback for order: " + orderId);
        }
    }

    // Saga Orchestrator
    class SagaOrchestrator {
        public void executeSaga(String orderId, double amount) {
            PlaceOrderService orderService = new PlaceOrderService();
            PaymentService paymentService = new PaymentService();
            InventoryService inventoryService = new InventoryService();

            try {
                orderService.placeOrder(orderId);
                paymentService.processPayment(orderId, amount);
                inventoryService.updateInventory(orderId);
                System.out.println("Transaction completed successfully!");
            } catch (Exception e) {
                System.out.println("Error: " + e.getMessage());
                orderService.rollbackOrder(orderId);
                paymentService.refundPayment(orderId);
                inventoryService.rollbackInventory(orderId);
            }
        }
    }

    public class Main {
        public static void main(String[] args) {
            SagaOrchestrator orchestrator = new SagaOrchestrator();
            orchestrator.executeSaga("ORD123", 1500); // Simulate payment failure
        }
    }

------------------------------------------------------------------------------------------------------------------------
2. What is the Circuit Breaker Pattern?
The Circuit Breaker pattern is used in microservices to prevent cascading failures when one service repeatedly
calls another that is slow or unavailable.
It acts like an electrical circuit breaker ‚Äî stopping calls to a failing service for a certain time to give it a
chance to recover.

‚öôÔ∏è How It Works:
Closed State:
All requests pass through normally.
Failures are counted.
When failures exceed a threshold (e.g., 5 consecutive failures), the breaker ‚Äúopens.‚Äù

Open State:
Requests are immediately failed or redirected (no waiting for timeouts).
After a cooldown period, the breaker moves to Half-Open.

Half-Open State:
A few test requests are allowed through.
If they succeed ‚Üí breaker closes (normal flow resumes).
If they fail ‚Üí breaker opens again.

üß† Example:
If Order Service calls Payment Service, and Payment Service goes down, the circuit breaker (e.g., via Resilience4j)
will stop further calls to prevent Order Service from hanging or crashing.

‚úÖ In short:
The Circuit Breaker pattern helps make microservices resilient by stopping repeated calls to failing services,
allowing recovery and protecting the overall system from failure.


Definition:
The Circuit Breaker Pattern is used to prevent cascading failures in distributed systems by temporarily halting requests
to a failing service.

Use Case in Payment Systems:
If a third-party payment gateway is unresponsive, the circuit breaker can block further requests and fallback to an alternative.

Example:
    class CircuitBreaker {
        private boolean open = false;

        public boolean isOpen() {
            return open;
        }

        public void open() {
            System.out.println("Circuit opened. Blocking further requests.");
            open = true;
        }

        public void close() {
            System.out.println("Circuit closed. Resuming requests.");
            open = false;
        }
    }

    class PaymentGateway {
        private CircuitBreaker circuitBreaker = new CircuitBreaker();

        public void processPayment(String orderId, double amount) {
            if (circuitBreaker.isOpen()) {
                System.out.println("Request blocked for order: " + orderId);
                return;
            }

            try {
                System.out.println("Processing payment for order: " + orderId);
                // Simulate gateway failure
                throw new RuntimeException("Gateway timeout");
            } catch (Exception e) {
                System.out.println("Error: " + e.getMessage());
                circuitBreaker.open();
            }
        }
    }

    public class CircuitBreakerExample {
        public static void main(String[] args) {
            PaymentGateway gateway = new PaymentGateway();
            gateway.processPayment("ORD123", 500.0);
            gateway.processPayment("ORD124", 600.0);
        }
    }

------------------------------------------------------------------------------------------------------------------------
3. How would you handle failures in a microservices architecture without using the Circuit Breaker Pattern?

1. Retry Pattern
Definition:
Automatically retry a failed request a certain number of times before considering it a permanent failure.

Implementation:

Configure retry logic with exponential backoff to avoid overwhelming the failing service.
Use libraries like Resilience4j or Spring Retry for managing retries in Java.
Example in Payment Systems:
Retry a failed payment gateway request before marking it as failed.

    public class PaymentService {
        public void processPayment(String orderId, double amount) {
            int retries = 3;
            while (retries > 0) {
                try {
                    System.out.println("Attempting payment for order: " + orderId);
                    // Simulate random failure
                    if (Math.random() > 0.5) {
                        throw new RuntimeException("Payment gateway error");
                    }
                    System.out.println("Payment successful for order: " + orderId);
                    return;
                } catch (Exception e) {
                    System.out.println("Error: " + e.getMessage());
                    retries--;
                    if (retries == 0) {
                        System.out.println("Payment failed after retries for order: " + orderId);
                    }
                }
            }
        }
    }

------------------------------------------------------------------------------------------------------------------------
4. What is CQRS?
    CQRS stands for Command Query Responsibility Segregation.
    It is a design pattern that separates read operations (queries) from write operations (commands) in an application.
    We often combined CQRS with event-driven architecture to synchronize read and write models effectively.

    * Command: Handles write operations (e.g., create, update, delete).
    * Query: Handles read operations (e.g., fetch data, retrieve details).

    Benefits of CQRS:
        1. Scalability: Read and write operations can be scaled independently.
        2. Performance: Read operations can be optimized separately, such as using denormalized data.
        3. Flexibility: Enables better handling of complex business rules during write operations.

    Example of CQRS in Your Payment Domain:
        In a payment system:
        * Commands handle actions like processing payments, updating balances, or refunding transactions.
        * Queries handle fetching transaction history or user account balances.

    1. Command: Write Model
    // Command: Process Payment
    public class ProcessPaymentCommand {
        private String transactionId;
        private double amount;

        // Constructor, getters, and setters
    }

    public class PaymentService {
        public void processPayment(ProcessPaymentCommand command) {
            // Validate command
            // Update balance in database
            // Publish event (e.g., PaymentProcessedEvent)
            System.out.println("Payment processed for transaction: " + command.getTransactionId());
        }
    }

    2. Query: Read Model
    public class TransactionQueryService {
        private final TransactionRepository repository;

        public TransactionQueryService(TransactionRepository repository) {
            this.repository = repository;
        }

        public List<Transaction> getTransactionHistory(String userId) {
            // Optimized query to fetch transaction history
            return repository.findByUserId(userId);
        }
    }

------------------------------------------------------------------------------------------------------------------------
5. What is Service Discovery (Eureka)?
Service Discovery is a mechanism that allows microservices to automatically register and locate each other
without hardcoding service URLs.
In Spring Cloud, Eureka (by Netflix) is a popular Service Discovery Server.

‚öôÔ∏è How It Works:
Eureka Server ‚Äì acts as a registry where all services register themselves with their network details (host, port, etc.).
Eureka Client ‚Äì each microservice registers with Eureka and can also discover other registered services to call them dynamically.

üß† Example:
Order Service registers with Eureka as order-service.
Payment Service registers as payment-service.
When Order Service needs to call Payment Service, it asks Eureka for its location instead of using a fixed URL.

‚úÖ In short:
Eureka Service Discovery enables dynamic registration and lookup of microservices, making the system more scalable, fault-tolerant, and flexible (no manual configuration of service endpoints).
------------------------------------------------------------------------------------------------------------------------
What is distributed tracing (Zipkin / Sleuth)?
Distributed Tracing is used to track requests as they flow across multiple microservices, helping developers
identify performance bottlenecks and failures in complex distributed systems.

‚öôÔ∏è Spring Cloud Sleuth
Spring Cloud Sleuth automatically adds trace IDs and span IDs to logs for each request.
These IDs help you trace a request across multiple services.
Example: When a request travels from Order Service ‚Üí Payment Service ‚Üí Notification Service, Sleuth adds a common
trace ID to each log.

üìä Zipkin
Zipkin is a distributed tracing server that collects, stores, and visualizes trace data sent from Sleuth-enabled applications.
It provides a web UI to see request latency, dependency graphs, and slow services.

‚úÖ In short:

Sleuth adds trace information to logs, and Zipkin visualizes that data to help monitor and debug request flows across
 microservices.
------------------------------------------------------------------------------------------------------------------------


