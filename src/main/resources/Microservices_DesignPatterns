



Q1: Design API Gateway?
An API Gateway acts as the entry point for all client requests and routes them to the appropriate microservices.
It helps in security, authentication, load balancing, rate limiting, monitoring, and caching.

A large e-commerce platform where multiple clients (web, mobile, third-party) need to interact with various services
(catalog, user management, orders).
The API Gateway simplifies client communication by providing a unified interface and handling complexities like
security and routing.

    Key Features of an API Gateway
    * Single Entry Point ‚Üí Clients call the API Gateway instead of calling microservices directly.
    * Routing & Load Balancing ‚Üí Directs requests to appropriate microservices.
    * Authentication & Security ‚Üí Uses JWT/OAuth2.0 for authentication.
    * Rate Limiting & Throttling ‚Üí Prevents excessive API calls using Redis-based limits.
    * Monitoring & Logging ‚Üí Tracks API usage with Prometheus/Grafana.
    * Caching ‚Üí Uses Redis or in-memory cache for faster responses.

    2Ô∏è‚É£ API Gateway High-Level Design (HLD)
                            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                            ‚îÇ        Client (UI/Mobile) ‚îÇ
                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                           ‚îÇ
                                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                  ‚îÇ    API Gateway   ‚îÇ  (Spring Cloud Gateway / Kong / Nginx)
                                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                           ‚îÇ
             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
             ‚îÇ               ‚îÇ                            ‚îÇ                   ‚îÇ
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ User Service  ‚îÇ ‚îÇ Order Svc  ‚îÇ             ‚îÇ Product Svc  ‚îÇ     ‚îÇ Payment Service  ‚îÇ
     ‚îÇ Auth, Profile ‚îÇ ‚îÇ Orders CRUD‚îÇ             ‚îÇ Catalog API  ‚îÇ     ‚îÇ Payment Gateway  ‚îÇ
     ‚îÇ PostgreSQL    ‚îÇ ‚îÇ MySQL      ‚îÇ             ‚îÇ MongoDB      ‚îÇ     ‚îÇ Razorpay, Stripe ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
------------------------------------------------------------------------------------------------------------------------

1. What is the Saga Pattern?
Definition:
The Saga Pattern is a design pattern for managing distributed transactions in microservices. Instead of using a single
global transaction, it breaks a transaction into a series of smaller steps, where each step is a local transaction in a service.
If one step fails, a compensating action is triggered to rollback changes made by the previous steps.

Saga manages distributed transactions across multiple microservices by coordinating a sequence of local transactions.
Each service performs its transaction and publishes an event triggering the next service‚Äôs transaction.
If a transaction fails, compensating transactions undo the changes.

Use Case in Payment Systems:
A payment processing workflow that involves multiple services like Order Service, Payment Service, and Inventory Service.
If payment fails, the order and inventory changes should be rolled back.

An order processing system where placing an order involves multiple services (payment, inventory, shipping). The saga
pattern ensures that all steps are completed successfully, and if any step fails, compensating actions roll back the
previous steps.

Example:
    // Step 1: Place Order
    class PlaceOrderService {
        public void placeOrder(String orderId) {
            System.out.println("Order placed: " + orderId);
        }

        public void rollbackOrder(String orderId) {
            System.out.println("Order rolled back: " + orderId);
        }
    }

    // Step 2: Deduct Payment
    class PaymentService {
        public void processPayment(String orderId, double amount) {
            if (amount > 1000) {
                throw new RuntimeException("Payment failed for order: " + orderId);
            }
            System.out.println("Payment processed for order: " + orderId);
        }

        public void refundPayment(String orderId) {
            System.out.println("Payment refunded for order: " + orderId);
        }
    }

    // Step 3: Update Inventory
    class InventoryService {
        public void updateInventory(String orderId) {
            System.out.println("Inventory updated for order: " + orderId);
        }

        public void rollbackInventory(String orderId) {
            System.out.println("Inventory rollback for order: " + orderId);
        }
    }

    // Saga Orchestrator
    class SagaOrchestrator {
        public void executeSaga(String orderId, double amount) {
            PlaceOrderService orderService = new PlaceOrderService();
            PaymentService paymentService = new PaymentService();
            InventoryService inventoryService = new InventoryService();

            try {
                orderService.placeOrder(orderId);
                paymentService.processPayment(orderId, amount);
                inventoryService.updateInventory(orderId);
                System.out.println("Transaction completed successfully!");
            } catch (Exception e) {
                System.out.println("Error: " + e.getMessage());
                orderService.rollbackOrder(orderId);
                paymentService.refundPayment(orderId);
                inventoryService.rollbackInventory(orderId);
            }
        }
    }

    public class Main {
        public static void main(String[] args) {
            SagaOrchestrator orchestrator = new SagaOrchestrator();
            orchestrator.executeSaga("ORD123", 1500); // Simulate payment failure
        }
    }

------------------------------------------------------------------------------------------------------------------------
2. What is the Circuit Breaker Pattern?
The Circuit Breaker pattern is used in microservices to prevent cascading failures when one service repeatedly
calls another that is slow or unavailable.
It acts like an electrical circuit breaker ‚Äî stopping calls to a failing service for a certain time to give it a
chance to recover.

This pattern prevents service failure by providing a fallback mechanism when a service is unreachable or fails.
It monitors service calls and "breaks" the circuit to prevent further calls when failures exceed a threshold.

‚öôÔ∏è How It Works:
Closed State:
All requests pass through normally.
Failures are counted.
When failures exceed a threshold (e.g., 5 consecutive failures), the breaker ‚Äúopens.‚Äù

Open State:
Requests are immediately failed or redirected (no waiting for timeouts).
After a cooldown period, the breaker moves to Half-Open.

Half-Open State:
A few test requests are allowed through.
If they succeed ‚Üí breaker closes (normal flow resumes).
If they fail ‚Üí breaker opens again.

üß† Example:
If Order Service calls Payment Service, and Payment Service goes down, the circuit breaker (e.g., via Resilience4j)
will stop further calls to prevent Order Service from hanging or crashing.

A travel booking system where multiple external services (airline, hotel, car rental) are integrated. If one service is
slow or fails, the circuit breaker prevents cascading failures and provides a default response to maintain system stability.


Use Case in Payment Systems:
If a third-party payment gateway is unresponsive, the circuit breaker can block further requests and fallback to an alternative.

Example:
    class CircuitBreaker {
        private boolean open = false;

        public boolean isOpen() {
            return open;
        }

        public void open() {
            System.out.println("Circuit opened. Blocking further requests.");
            open = true;
        }

        public void close() {
            System.out.println("Circuit closed. Resuming requests.");
            open = false;
        }
    }

    class PaymentGateway {
        private CircuitBreaker circuitBreaker = new CircuitBreaker();

        public void processPayment(String orderId, double amount) {
            if (circuitBreaker.isOpen()) {
                System.out.println("Request blocked for order: " + orderId);
                return;
            }

            try {
                System.out.println("Processing payment for order: " + orderId);
                // Simulate gateway failure
                throw new RuntimeException("Gateway timeout");
            } catch (Exception e) {
                System.out.println("Error: " + e.getMessage());
                circuitBreaker.open();
            }
        }
    }

    public class CircuitBreakerExample {
        public static void main(String[] args) {
            PaymentGateway gateway = new PaymentGateway();
            gateway.processPayment("ORD123", 500.0);
            gateway.processPayment("ORD124", 600.0);
        }
    }

------------------------------------------------------------------------------------------------------------------------
3. How would you handle failures in a microservices architecture without using the Circuit Breaker Pattern?

1. Retry Pattern
Definition:
Automatically retry a failed request a certain number of times before considering it a permanent failure.

Implementation:

Configure retry logic with exponential backoff to avoid overwhelming the failing service.
Use libraries like Resilience4j or Spring Retry for managing retries in Java.
Example in Payment Systems:
Retry a failed payment gateway request before marking it as failed.

    public class PaymentService {
        public void processPayment(String orderId, double amount) {
            int retries = 3;
            while (retries > 0) {
                try {
                    System.out.println("Attempting payment for order: " + orderId);
                    // Simulate random failure
                    if (Math.random() > 0.5) {
                        throw new RuntimeException("Payment gateway error");
                    }
                    System.out.println("Payment successful for order: " + orderId);
                    return;
                } catch (Exception e) {
                    System.out.println("Error: " + e.getMessage());
                    retries--;
                    if (retries == 0) {
                        System.out.println("Payment failed after retries for order: " + orderId);
                    }
                }
            }
        }
    }

------------------------------------------------------------------------------------------------------------------------
4. What is CQRS?
    CQRS stands for Command Query Responsibility Segregation.
    It is a design pattern that separates read operations (queries) from write operations (commands) in an application.
    We often combined CQRS with event-driven architecture to synchronize read and write models effectively.

    * Command: Handles write operations (e.g., create, update, delete).
    * Query: Handles read operations (e.g., fetch data, retrieve details).

    Benefits of CQRS:
        1. Scalability: Read and write operations can be scaled independently.
        2. Performance: Read operations can be optimized separately, such as using denormalized data.
        3. Flexibility: Enables better handling of complex business rules during write operations.

    Example of CQRS in Your Payment Domain:
        In a payment system:
        * Commands handle actions like processing payments, updating balances, or refunding transactions.
        * Queries handle fetching transaction history or user account balances.

    1. Command: Write Model
    // Command: Process Payment
    public class ProcessPaymentCommand {
        private String transactionId;
        private double amount;

        // Constructor, getters, and setters
    }

    public class PaymentService {
        public void processPayment(ProcessPaymentCommand command) {
            // Validate command
            // Update balance in database
            // Publish event (e.g., PaymentProcessedEvent)
            System.out.println("Payment processed for transaction: " + command.getTransactionId());
        }
    }

    2. Query: Read Model
    public class TransactionQueryService {
        private final TransactionRepository repository;

        public TransactionQueryService(TransactionRepository repository) {
            this.repository = repository;
        }

        public List<Transaction> getTransactionHistory(String userId) {
            // Optimized query to fetch transaction history
            return repository.findByUserId(userId);
        }
    }

------------------------------------------------------------------------------------------------------------------------
5. What is Service Discovery (Eureka)?
Service Discovery allows microservices to find and communicate with each other dynamically. It involves a
service registry where services register themselves and look up other services.

In Spring Cloud, Eureka (by Netflix) is a popular Service Discovery Server.
‚öôÔ∏è How It Works:
Eureka Server ‚Äì acts as a registry where all services register themselves with their network details (host, port, etc.).
Eureka Client ‚Äì each microservice registers with Eureka and can also discover other registered services to call them dynamically.

üß† Example:
Order Service registers with Eureka as order-service.
Payment Service registers as payment-service.
When Order Service needs to call Payment Service, it asks Eureka for its location instead of using a fixed URL.

real life ex: A microservices-based application deployed in a cloud
            environment where instances of services start and stop
            frequently. Service discovery ensures that services can
            locate each other without manual configuration, enabling
            automatic scaling and resilience.
------------------------------------------------------------------------------------------------------------------------
What is distributed tracing (Zipkin / Sleuth)?
Distributed Tracing is used to track requests as they flow across multiple microservices, helping developers
identify performance bottlenecks and failures in complex distributed systems.

‚öôÔ∏è Spring Cloud Sleuth
Spring Cloud Sleuth automatically adds trace IDs and span IDs to logs for each request.
These IDs help you trace a request across multiple services.
Example: When a request travels from Order Service ‚Üí Payment Service ‚Üí Notification Service, Sleuth adds a common
trace ID to each log.

üìä Zipkin
Zipkin is a distributed tracing server that collects, stores, and visualizes trace data sent from Sleuth-enabled applications.
It provides a web UI to see request latency, dependency graphs, and slow services.

‚úÖ In short:

Sleuth adds trace information to logs, and Zipkin visualizes that data to help monitor and debug request flows across
 microservices.
------------------------------------------------------------------------------------------------------------------------


