Write a query to find the 2nd highest salary.
SELECT DISTINCT salary
FROM employee
ORDER BY salary DESC
LIMIT 1 OFFSET 1;

SELECT MAX(salary)
FROM employee
WHERE salary < (SELECT MAX(salary) FROM employee);
========================================================================================================================
Difference between INNER JOIN, LEFT JOIN, and RIGHT JOIN.
â€œINNER JOIN gives only matching rows,
LEFT JOIN gives all from left + matches,
RIGHT JOIN gives all from right + matches.â€

SELECT e.name, d.dept_name
FROM employee e
INNER JOIN department d ON e.dept_id = d.id;
========================================================================================================================
What is normalization?
Normalization is the process of organizing data in a database to reduce redundancy and improve data integrity.
It divides large tables into smaller related tables and establishes relationships between them using foreign keys.

ðŸ§  Example:
Denormalized â†’ employee table with department name repeated in every row.
Normalized â†’ separate Employee and Department tables, linked by dept_id.
========================================================================================================================
How do you optimize a slow query?
I usually optimize slow queries by:
Analyzing execution plan using EXPLAIN to find bottlenecks.
Creating indexes on columns used in WHERE, JOIN, or ORDER BY.
**Avoiding SELECT *** â€” fetch only required columns.
Reducing subqueries â€” use joins or CTEs where possible.
Avoiding functions on indexed columns (e.g., WHERE UPPER(name) prevents index usage).
Using proper joins instead of nested loops or correlated subqueries.
Caching repeated queries at the app level when possible.
Archiving old data if the table is very large.

EXPLAIN SELECT * FROM employee WHERE dept_id = 10;
========================================================================================================================
What are indexes and when should you use them?
An index is a database structure that improves the speed of data retrieval.
It works like an index in a book â€” helps the database find rows faster without scanning the entire table.
âœ… When to Use:
Columns in WHERE, JOIN, GROUP BY, or ORDER BY.
Frequently searched fields (e.g., email, dept_id).
âš ï¸ Avoid Indexes When:
The table is small.
The column has low selectivity (e.g., gender = M/F).
Frequent inserts/updates â€” since indexes slow down write operations.
========================================================================================================================
Explain transactions and ACID properties.
Transaction (one-line): A transaction is a sequence of database operations executed as a single logical unit so that
either all operations succeed (commit) or none take effect (rollback).
Why use a transaction (one-line): To preserve data integrity when multiple related changes must succeed together
(e.g., money transfer: debit and credit).

ACID properties â€” one line each with a tiny example:
A â€” Atomicity: Either all operations in the transaction are applied or none are â€” there is no partial application.
Example: If a transfer debits A but fails to credit B, the whole transaction is rolled back so neither change persists.

C â€” Consistency: A transaction transforms the database from one valid state to another valid state, preserving all
defined rules, constraints and invariants.
Example: If a constraint requires total balance â‰¥ 0, transactions must not leave the database violating that rule.

I â€” Isolation: Concurrent transactions behave as if they were executed serially (isolation level controls visibility
and anomalies).
Example: Two simultaneous transfers should not see each otherâ€™s intermediate (uncommitted) changes.

D â€” Durability: Once a transaction commits, its effects are permanent â€” they survive crashes or restarts.
Example: After commit, updated balances remain even if the DB server restarts immediately.

Practical note (one-line): Isolation has multiple levels
 (READ UNCOMMITTED â†’ READ COMMITTED â†’ REPEATABLE READ â†’ SERIALIZABLE) that trade performance for fewer concurrency anomalies.

 ========================================================================================================================
What is the difference between DELETE, TRUNCATE, and DROP?
DELETE (one-line): DELETE FROM table [WHERE condition] removes selected rows; it is a DML operation, can be rolled
back inside a transaction, and fires row-level triggers.
Example: DELETE FROM employee WHERE id = 10; â€” removes that row only.

TRUNCATE (one-line): TRUNCATE TABLE table removes all rows quickly (often by deallocating data pages); it is usually
treated as DDL or a minimally-logged operation and is typically faster than DELETE for clearing a table.
Behavior note: In many DBMS TRUNCATE is non-transactional (cannot be rolled back) because it is DDL; however,
some systems (e.g., PostgreSQL) treat TRUNCATE as transactional and it can be rolled back â€” so check your RDBMS.
Example: TRUNCATE TABLE employee; â€” removes all rows quickly and resets storage.

DROP (one-line): DROP TABLE table removes the table definition and its data from the schema (structure + data);
it is DDL, cannot be used to delete a subset of rows, and typically cannot be rolled back in many systems.
Example: DROP TABLE employee; â€” table no longer exists.

Effect on schema and dependent objects (one-line):

DELETE does not change table structure or reset identity counters.

TRUNCATE usually resets identity/auto-increment counters (depends on DB).

DROP removes the table and its metadata; dependent objects (indexes, constraints) are removed too.

Performance & logging (one-line): DELETE logs individual row deletions (slower, heavier WAL/redo), TRUNCATE is usually minimally logged or metadata-only (faster), DROP is metadata removal (fastest).

Triggers & constraints (one-line): DELETE fires DELETE triggers; TRUNCATE usually does not fire row-level triggers; DROP also does not fire row-level triggers (but may affect DDL triggers if DB supports them).

Transactional safety (one-line): Use DELETE when you need transactional safety and selective removal; use TRUNCATE for fast removal of all rows when you donâ€™t need per-row auditing and you understand your RDBMSâ€™s transaction behavior; use DROP when you want to remove the entire table structure.